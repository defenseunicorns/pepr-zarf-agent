/// <reference types="node" />
import { V1ClusterRole, V1ClusterRoleBinding, V1Deployment, V1MutatingWebhookConfiguration, V1Namespace, V1NetworkPolicy, V1RuleWithOperations, V1Secret, V1Service, V1ServiceAccount } from "@kubernetes/client-node";
import { ModuleConfig } from "../types";
import { TLSOut } from "./tls";
export declare class Webhook {
    private readonly config;
    private readonly host?;
    private name;
    private _tls;
    image: string;
    get tls(): TLSOut;
    constructor(config: ModuleConfig, host?: string | undefined);
    /** Generate the pepr-system namespace */
    namespace(): V1Namespace;
    /**
     * Grants the controller access to cluster resources beyond the mutating webhook.
     *
     * @todo: should dynamically generate this based on resources used by the module. will also need to explore how this should work for multiple modules.
     * @returns
     */
    clusterRole(): V1ClusterRole;
    clusterRoleBinding(): V1ClusterRoleBinding;
    serviceAccount(): V1ServiceAccount;
    tlsSecret(): V1Secret;
    generateWebhookRules(path: string): Promise<V1RuleWithOperations[]>;
    mutatingWebhook(path: string, timeoutSeconds?: number): Promise<V1MutatingWebhookConfiguration>;
    deployment(hash: string): V1Deployment;
    /** Only permit the kube-system ns ingress access to the controller */
    networkPolicy(): V1NetworkPolicy;
    service(): V1Service;
    moduleSecret(data: Buffer, hash: string): V1Secret;
    zarfYaml(path: string): string;
    allYaml(path: string): Promise<string>;
    deploy(path: string, webhookTimeout?: number): Promise<void>;
}
//# sourceMappingURL=webhook.d.ts.map